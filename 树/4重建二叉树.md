**原题4：**重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

**不懂的点（难点）：**二叉树的结构（题目也给了）。前序遍历，中序遍历。（前序是先根，同级先左后根；中序是先左后根最后右）递归思想（即自己调用自己，记得还有有跳出调用的基准条件）。数组划分（用slice(0,n2)，注意是这里不包括n2，或者slice(n2+1)）

**思路：**做这种有关树、链表的题一定要有递归的思想，总之该题的解题思路就是四步:

1 确定根,确定左子树，确定右子树。

2 在左子树中递归。

3 在右子树中递归。

4 打印当前根。

 本题：先看前序遍历，发现1是根，根据1是根，看中序遍历，可知{4，7，2}是左子树，{5，3，8，6}是右子树；左子树中，由前序遍历结果可以知道，2是根节点，再看中序遍历结果，2左边{4，7}是左子树，右边没有，即空，然后看{4，7}，由前序遍历结果可知，4是根节点；由中序遍历结果，7是4是有子树。依次下去。

即前序确定根，基于根看中序确定左右子树。

（此外，必须让叶子节点和空节点返回Null，也是递归的回调的基准条件；）

**答案：**

``` javascript
/* function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
} */
function reConstructBinaryTree(pre, vin)
{
    // write code here
    //边界条件
    if (pre.length === 0 || vin.length === 0) {
        return null;
    }
    let index = vin.indexOf(pre[0]);
    let left = vin.slice(0, index);
    let right = vin.slice(index + 1);
    return {
        val : pre[0],
        left : reConstructBinaryTree(pre.slice(1, index + 1), left),
        right : reConstructBinaryTree(pre.slice(index + 1), right)
    }
}
```

（这里最后返回使用的是ES6的对象方式，直接返回同名遍历的对象，注意是逗号隔开，而不是分号，不然会报错；而且slice(start, end)是不包括end元素的）

**别人优秀的思路点：**记得考虑边界条件。

知识点补充：

（前中后是指的访问根节点的3步中的第几步）

前序遍历（VLR）： 
  1.访问根节点 
  2.前序遍历左子树 
  3.前序遍历右子树 
中序遍历（LVR）： 
  1.中序遍历左子树 
  2.访问根节点 
  3.中序遍历右子树 
后序遍历（LRV）： 
  1.后序遍历左子树 
  2.后序遍历右子树 
  3.访问根节点